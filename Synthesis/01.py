# Created by Marc Ian D.S. Aquino
# CMSC 170 EF-4L

# Responsible use:
# The programmer did not use any AI when writing the code. The programmer used python.org documentations for searching the proper usage of functions such as printing, variable passing, and map() function.
# No part of the program is generated by AI.
# The programmer did not use AI for completing the exercise, and is able to complete the task with the help of tutorial websites for Python programming such as W3Schools, docs.python.org, and geeksforgeeks.org.

# Tic-Tac-Toe with implementation of alpha-beta pruning and minimax search

import random # import the 'random' library to introduce the random move of the AI
def print_board(board):
    print("\nTic-Tac-Toe Board:")
    print("    1   2   3")  # Column numbers
    print("  +---+---+---+")
    for i in range(3):
        print(f"{i+1} | {board[i][0]} | {board[i][1]} | {board[i][2]} |")
        print("  +---+---+---+")
    print()

def check_winner(board):
    for i in range(3):     # rows
        if board[i][0] == board[i][1] == board[i][2] != ' ':
            return board[i][0]
    for j in range(3):     # columns
        if board[0][j] == board[1][j] == board[2][j] != ' ':
            return board[0][j]
    if board[0][0] == board[1][1] == board[2][2] != ' ':
        return board[0][0]
    if board[0][2] == board[1][1] == board[2][0] != ' ':
        return board[0][2]
    return None
def full_board(board):
    for row in board:
        if ' ' in row:
            return False
    return True

def make_move(board, row, col, player):
    if 0 <= row < 3 and 0 <= col < 3 and board[row][col] == ' ':
        board[row][col] = player
        return True
    return False

def available_moves(board):
    moves = []
    for r in range(3):
        for c in range(3):
            if board[r][c] == ' ':
                moves.append((r, c))
    return moves

def minimax(board, depth, maximizemove, computer, human_player, alpha, beta):
    winner = check_winner(board)
    if winner == computer:
        return 10-depth # if the computer won, add 10 to the score
    elif winner == human_player:
        return depth-10  # if the human player won, subtract 10 from the score
    elif full_board(board):
        return 0
    if maximizemove:
        best_score = -10**9 # max negative 
        for (r,c) in available_moves(board):
            board[r][c] = computer # place the computer's move
            score = minimax(board, depth+1, False, computer, human_player, alpha, beta)
            board[r][c] = ' '
            best_score = max(best_score, score)
            alpha = max(alpha, score) # get the highest value of score
            if beta <= alpha:
                break
        return best_score
    else: # If it is the human's turn, the computer will minimize
        minimumvalue = 10**9
        for (r,c) in available_moves(board):
            board[r][c] = human_player
            score = minimax(board, depth+1, True, computer, human_player, alpha, beta)
            board[r][c] = ' '
            minimumvalue = min(minimumvalue, score)
            beta = min(beta, score) # get the lowest value of score
            if beta <= alpha:
                break  # cut-off if the value goes too high/low
        return minimumvalue

def pruning(board, computer, human_player):
    best_val = -10**9
    best_moves = [] # list down the best move given the current board's state
    for (r,c) in available_moves(board):
        board[r][c] = computer
        current_value = minimax(board, 0, False, computer, human_player, -10**9, 10**9)
        board[r][c] = ' '
        if current_value > best_val: # Check if the current value is greater than known "at most"
            best_val = current_value # reassign the value if true
            best_moves = [(r,c)]
        elif current_value == best_val:
            best_moves.append((r,c)) # append the best move the computer saw
    # choose randomly among equally good moves for variety
    return random.choice(best_moves) if best_moves else None

def firstrandommove(board, computer): # Randomize computer opening move among center and corners for variability
    openingmove=[]
    # center
    if board[1][1] == ' ':
        openingmove.append((1,1))
    for r,c in [(0,0),(0,2),(2,0),(2,2)]:   # corners
        if board[r][c] == ' ':
            openingmove.append((r,c))
    if openingmove:
        return random.choice(openingmove)
    moves = available_moves(board)
    return random.choice(moves) if moves else None

def playermove(board, human_player):
    while True:
        try:
            move = input("Enter your move (row,col): ").strip()
            row,col = map(int, move.split(',')) # get the player's move
            if make_move(board, row-1, col-1, human_player):
                break
            else:
                print("Invalid move! That cell is occupied or out of range.")
        except (ValueError, IndexError):
            print("Please enter row and column as numbers (e.g., 1,2)")

def game_loop():
    # choose the player's preferred symbol
    while True:
        human_player = input("Choose your symbol (X/O): ").strip().upper() # c
        if human_player in ('X','O'):
            break
        print("Please enter X or O.")
    computer = 'O' if human_player == 'X' else 'X'
    #choose who goes first
    while True:
        firstmove = input("Do you want to go first? (y/n): ").strip().lower()
        if firstmove in ('y','n'):
            human_first = (firstmove == 'y')
            break
        print("Please enter y or n.")
    board = [[' ' for _ in range(3)] for _ in range(3)] # initialize the board
    if human_first: #decide who moves first
        current_player = human_player
    else:
        current_player = computer
    while True:# game runs until winner or draw
        print_board(board)
        winner = check_winner(board)
        if winner:
            print(f"Player {winner} wins!")
            break
        if full_board(board):
            print("It's a draw!")
            break
        if current_player == human_player:
            print("Player's turn. ")
            playermove(board, human_player)
        else: # If the player decided to not move first, the function for the computer's first move is called
            if all(cell == ' ' for row in board for cell in row): # no moves on the board yet
                # Only randomize if AI is the one making the very first move
                if not human_first and computer == current_player:
                    r, c = firstrandommove(board, computer)
                    make_move(board, r, c, computer)
                else:
                    player = pruning(board, computer, human_player)
                    if computermove:
                        make_move(board, player[0], player[1], computer)
            else:
                player = pruning(board, computer, human_player)
                if player:
                    make_move(board, player[0], player[1], computer)
        current_player = 'O' if current_player == 'X' else 'X' # switch the current player
def main():
    print("Welcome to Tic-Tac-Toe!")
    game_loop() # call the game loop

if __name__ == "__main__":
    main()